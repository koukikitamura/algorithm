- 配列の全ての組み合わせを調べるときはある要素は要素の右側の組み合わせのみを保証するというロジックが良い
- グラフは隣接行列と隣接リストの2つの表し方がある。隣接行列はメモリが|V|^2に比例するが、重みも記録できる。構造体を使えば、隣接行列も重みを記録できる。
- 幅優先度探索やプリムのアルゴリズムでは次の隣接するノードを探す際に、使われていないの条件を忘れずに入れる。
- プリムのアルゴリズムは全域木(MinimumSpanningTree)を求め、ダイクストラのアルゴリズムは2点間の頂点の最短経路を求める。
- 探索やプリムのアルゴリズムで計算量を抑えるには、データをうまく記録する必要がある。プリムのアルゴリズムの場合MinimunSpanningTreeの親から自分への重みの累積和をvectorに記録すると計算量を押さられる。
- プリムのアルゴリズムもダイクストラのアルゴリズムもほぼ同じ。ダイクストラのアルゴリズムの場合はそのノードへの
最小経路の重みの累積和を記録する。
- 漸化式で表せるものは動的計画法(DP)やメモ化再帰が使える。漸化式 = 再帰関数。
- 配列の最小値を求める場合、maxの初期値を配列の1つ目にする方法とinfinityにする方法の2つがある。
- graphの表現の仕方には隣接リスト(adjacency list)と隣接行列(adjacency matrix)の２つがある。入力は隣接リスト(adjacency list)だが扱うときは隣接行列(adjacency matrices)なことが多い。隣接行列はvertexの数の２乗に比例してメモリを消費する。隣接行列はedgeの数が少ないときはメモリを無駄遣い。n = 100,000くらいでedgeの数が少ない場合は隣接リストを使った方が良い。
- 最小公倍数はa > bのときGCD(a, b) = GCD(b, a % b)となりa % bが0になった時の小さい方が最小公倍数。
- １は素数でない。素数ではい数を合成数と呼ぶ。「合成数xは p <= √x を満たす素因子をもつ」という性質を使えば計算量√nで
判定できる。xが合成数なら「1 < p <= √x」の条件を満たす約数pが存在する
