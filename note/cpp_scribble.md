- switch(expression)のexpressionは数値である必要がある。stringはだめ。
- operatorはc++の予約語
- シングルクォートはchar、ダブルクォートはchar*。char*とstringは==比較可能。
- breakはループとswitch文のみで使える。if文では使えない
- 文末には全てセミコロンをつける
- mainは関数でreturnを省略すると0を返すようにコンパイルされる。
  0以外を返すと異常値として扱われるが処理が決まっている訳ではない｡
  0以外を返すとAtCoderでRE(Runtime Error)になる。
  void mainはc++の標準では禁止されている
- boolean型ではなくbool型
- c++は0とfalseが偽、0以外の数値とtrueが真
- プロパティをコンストラクタで初期化するとそのクラスの型をもつ変数を定義した時にコンストラクトに渡す
　ので初期化しないでクラスの型の変数宣言ができない。
- vectorは可変長配列。メモリをあらかじめ確保するにはresizeとreserveがある。resizeはiteratorのendをsize - 1に動かすがreserveが動かさない。[]でアクセスする場合はresizeを使って、push_backを使う場合はreserveを使う。
- 数値のdelimeterは'だが、c++14以上。
- 配列の要素数が100万を越えるとスタックオバーフローする可能性がある。スタック領域は数MBなので。グローバル変数、vector、mallocを使ってヒープ領域にメモリを確保する。
- 配列を関数内側で変更すると配列は変更される。vectorの値を変更してもvectorの値は変更されない。基本的に値がコピーされる形で、配列の場合はポインタをコピーしているので配列を変更すると参照先を変更する形となり、元の配列が変更される。
ポインタの値渡しと参照渡しは異なる。配列の場合はポインタの値渡し。
- 引数に渡すvectorの要素数が大きい(10^6)くらいだとTime Limie Exceededになる。その場合はvectorをグローバル変数にすると早くなる。
- vector#push_backをすると自動的にresizeされる。ただし、明示的にreiszeして容量が足りている時でもreseizeして容量が１増えてしまう。vector#backは末尾のデータを参照するだけ、vector#pop_backは末尾のデータを削除する(sizeを-1する)。
- priority queue はSTLとして #include <queue>で使える。
- fibonacchi数列のn = 44ですらもメモ化をしない再帰関数呼び出しをすると1sec以上かかる。
- 自分自身を2つ以上呼び出す可能性のある再帰関数はメモ化が有効。再帰関数は繰り返し処理に書き直せる。再帰関数でTimeExeecedErrorにる場合は関数内でメモ化すると2分以上から5秒程度に段違いに早くなる。関数呼び出しのコストがわかる。引数のvector or 文字列の要素数が多い場合は関数呼び出しは大きなコストとなり、実行時間が長くなる。再帰関数のよるメモ化より繰り返しによるメモ化の方が早い。n = 1000で再帰関数を呼び出すと、TimeExeededErrorになる可能性がある。
- 深さ優先度探索において、閉路がない有向グラフ(Directed Acyclic Graph)の場合は探索を2回以上やる必要がある。
- 入力は隣接リスト(adjacency list)だが扱うときは隣接行列(adjacency matrices)なことが多い。隣接行列はvertexの数の２乗に比例してメモリを消費する。隣接行列はedgeの数が少ないときはメモリを無駄遣い。
- サイズの大きいvector(10万程度)を値渡しして関数呼び出しをcallしまくる(5000回くらい)と関数呼び出しがオーバーヘッドになる。
この場合は引数をグローバル変数にするか参照渡しをして値をコピーしないようにする。
